* Links
*** https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph/
*** https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph-ii-file-format/
***** Structure of cg file:
****** Commit IDs: sorted and can be indexed as "Graph Position"
****** Fanout: 256 entries, The fanout value F[i] stores the number of commits whose first byte (or first two hex digits) of their ID is at most i. Thus, F[0xff] stores the total number of commits. This allows us to seed the initial values of the binary search into the commit IDs.
****** Commit Data:
******* Root Tree ID
******* Commit Date
******* "Graph Positions" of 2 parents as integers (not commit id, avoiding perform a binary search again)
****** Octopus Edges:
******* Second parent value of Commit Data : a position to octopus edges list to store the parents ( null-termination trick to let the list of parents be arbitrarily large)

***** Performance gains:
****** parsing the commit-graph file INSTEAD of raw commits
******* D: parsing this tabular data faster than unzipping and parsing the plain-text commit information
******* A: only need to do the binary search once for each of the starting positions of our walk (if commit exists in cg file , it's parents must be too)
****** from avoiding object database lookups
****** walking N commits went from O(N log N) as packfile  to O(N) as commit-graph
****** 5-10x speedup for certain Git commands.

*** https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph-iii-generations/

***** Change of the structure to cg file
******  Commit Data:
******* Commit Date 8 bytes:  split up to
******** commit date
******** generation number
***** Why not just use commit date
****** imsynchronized clock
***** Design of generation number
****** gen(Root) = 1
****** If gen(A) < gen(B) then A cannot reach B.
****** use generation to walk in order of descending instead of commit date
***** "Can X Reach Y ?"
****** git push --force:
******* if remote has a commit that local doesn't have on the same branch, push will fail,  then you need pull first or force push.
******* So the "X" here is the revision on server, "Y" is the revision on the local branch.  "Can X Reach Y ?" will perform a commit walk ordered by commit date starting from "X" and if "Y" appears during this walk , the result is YES, the push is safe because server already have the base X, if not, a force push may remove important history.
****** git status
*****  Using generation number for topo order (for accelerate)
****** topo order: è®©æ‰€æœ‰çš„è¾¹éƒ½æœä¸‹æŒ‡å‘ï¼Œ æ›´é€šä¿—çš„è®²ï¼Œ æ™®é€šcommitå¿…é¡»åœ¨å®ƒparentä¹‹å‰å‡ºç°ï¼ˆhttps://en.wikipedia.org/wiki/Topological_sortingï¼‰ï¼Œ è®©ä½ æ‰§è¡Œ `git log --graph`çš„æ—¶å€™ï¼Œå®é™…ä¸Šgitå°±ä¼šå¸®ä½ å®Œæˆtopological sortã€‚
****** TODO unfinished read

***** Performance gains:
****** force-push: å…¸å‹çš„ Xæ˜¯å¦å¯ä»¥reach Yçš„åœºæ™¯ï¼Œæ³¨æ„ reachçš„æ¦‚å¿µæŒ‡çš„æ˜¯æ²¿ç€DAGçš„è¾¹(edge)çš„æ–¹å‘(generation->root)æ˜¯å¦å¯è¾¾, å¦‚æœå¯è¾¾ï¼Œæˆ‘ä»¬å«åš"X can reach Y" æˆ–è€… "Y is reachable by X".  å›åˆ°pushï¼Œ 
*** https://devblogs.microsoft.com/devops/super-charging-the-git-commit-graph-iv-bloom-filters/
***** Why? -apply a filter to our results
***** Scenes:  `git log master -- The/Path/To/My/File.txt`
******  If the path is not modified very often...
****** In the example above, we need to walk five trees: the root tree and four nested trees for the directories above â€œFile.txtâ€.
***** How to show the specific path's commits (log)
******   [key problem] determine if a path is different between a commit and a parent is very expensive, especially as the number of subfolders increases (compare trees)
***** ä¸€ç§æ–¹å¼æ˜¯åœ¨æäº¤æ—¶ï¼Œ ç”¨æ•°æ®åº“è®°å½•"commit"<->"modified paths"çš„å…³è”å…³ç³», ä½†æ˜¯è¿™ä¼šå ç”¨å¤§é‡çš„ç©ºé—´ï¼ˆ60 GB just for the Linux kernel repositoryï¼‰
***** å¦ä¸€ç§å¸Œæœ›çš„æ–¹å¼æ˜¯ï¼Œ å¸Œæœ›æ•°æ®åº“å¯ä»¥ä¿å­˜ä¸¤ä¸ªç»“æœï¼š
****** 1. ç»™å®šcommitå’Œå…¶first-parentï¼Œ æŸä¸€ä¸ªpathæ˜¯å¦æ²¡æœ‰æ›´æ–°
****** 2. è¿™ä¸ªpathåœ¨è¿™ä¸ªæäº¤å’Œå®ƒçš„ç¬¬ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ä¹‹é—´â€œå¯èƒ½â€æ˜¯ä¸åŒçš„ã€‚
******  ä¸Šé¢ç¬¬2ç‚¹æåˆ°çš„"å¯èƒ½"å°±æ˜¯æˆ‘ä»¬ä½¿ç”¨bloom-filtersçš„åŸå› ã€‚å¦‚æœæˆ‘ä»¬æ˜ç¡®commitå’Œfirst-parentâ€œå¯èƒ½ä¸ä¸€æ ·â€ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿›ä¸€æ­¥æ¥ç¡®è®¤è¿™ä¸ªç­”æ¡ˆã€‚
***** About bloom filter
****** åŸºæœ¬æ€æƒ³ï¼š
******* 1. é€šè¿‡Hashå‡½æ•°å°†ä¸€ä¸ªå…ƒç´ æ˜ å°„æˆä¸€ä¸ªä½é˜µåˆ—ï¼ˆBit Arrayï¼‰ä¸­çš„ä¸€ä¸ªç‚¹ã€‚
******* 2. è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬åªè¦çœ‹çœ‹è¿™ä¸ªç‚¹æ˜¯ä¸æ˜¯ 1 å°±çŸ¥é“å¯ä»¥é›†åˆä¸­æœ‰æ²¡æœ‰å®ƒäº†ï¼Œå¦‚æœä¸€ä¸ªç‚¹ä¸åŒ¹é…ï¼Œé‚£ä¹ˆä¸€å®šæ²¡æœ‰ï¼› ç›¸åå¦‚æœæ‰€æœ‰çš„ç‚¹éƒ½æœ‰ï¼Œé‚£ä¹ˆåœ¨é›†åˆä¸­å¯èƒ½å­˜åœ¨ï¼ˆå› ä¸ºhashå†²çªçš„åŸå› ï¼Œ å­˜åœ¨è¯¯è¯†åˆ«ç‡ï¼‰ã€‚
******* 3. å¦‚æœè¿™å°±æ˜¯å¸ƒéš†è¿‡æ»¤å™¨çš„åŸºæœ¬æ€æƒ³ã€‚
****** ä¼˜åŠ¿ï¼šç©ºé—´æ•ˆç‡å’ŒæŸ¥è¯¢æ—¶é—´
******* æ²¡æœ‰è¯†åˆ«é”™è¯¯çš„æƒ…å†µï¼Œå³å‡åä¾‹ï¼ˆFalse negativesï¼‰ï¼Œå¦‚æœæŸä¸ªå…ƒç´ ç¡®å®æ²¡æœ‰åœ¨è¯¥é›†åˆä¸­ï¼Œé‚£ä¹ˆBloom Filter æ˜¯ä¸ä¼šæŠ¥å‘Šè¯¥å…ƒç´ å­˜åœ¨äºé›†åˆä¸­çš„ï¼Œæ‰€ä»¥ä¸ä¼šæ¼æŠ¥
******* æŸ¥è¯¢æŸ¥è¯¢æ—¶é—´å¤æ‚åº¦ï¼šO(1)
******* Hashå‡½æ•°äº’ç›¸ä¹‹é—´æ²¡æœ‰å…³ç³»ï¼Œ æ–¹ä¾¿ç”±ç¡¬ä»¶å¹¶è¡Œå®ç°
******* bloom filterä¸éœ€è¦å­˜å‚¨å…ƒç´ æœ¬èº«ï¼ŒæŸäº›å¯¹å®‰å…¨è¦æ±‚ä¸¥æ ¼çš„åœºåˆæœ‰ä¼˜åŠ¿
******* k (hashå‡½æ•°ä¸ªæ•°)å’Œ m (æ•°ç»„å¤§å°) ç›¸åŒï¼Œä½¿ç”¨åŒä¸€ç»„ Hash å‡½æ•°çš„ä¸¤ä¸ªå¸ƒéš†è¿‡æ»¤å™¨çš„äº¤å¹¶å·®è¿ç®—å¯ä»¥ä½¿ç”¨ä½æ“ä½œè¿›è¡Œ
****** åŠ£åŠ¿ï¼š
******* å­˜åœ¨ä¸€å®šè¯¯è¯†åˆ«ç‡ï¼ˆfalse-positiveï¼‰,å³Bloom FilteræŠ¥å‘ŠæŸä¸€å…ƒç´ å­˜åœ¨äºæŸé›†åˆä¸­ï¼Œä½†æ˜¯å®é™…ä¸Šè¯¥å…ƒç´ å¹¶ä¸åœ¨é›†åˆä¸­, å…¶æ ¹æºåœ¨äºåœ¨ç›¸åŒçš„bitä½è¢«å¤šä¸ªä¸åŒçš„elementç½®1; 
******* éšç€å­˜å…¥çš„å…ƒç´ æ•°é‡å¢åŠ ï¼Œè¯¯ç®—ç‡éšä¹‹å¢åŠ ï¼›
******* åˆ é™¤å›°éš¾ï¼› ä¸€èˆ¬æƒ…å†µä¸‹ä¸èƒ½ä»å¸ƒéš†è¿‡æ»¤å™¨ä¸­åˆ é™¤å…ƒç´ ï¼Œ å› ä¸ºbitä½å¹¶ä¸æ˜¯ç”±æŸä¸€ä¸ªç‰¹å®šelementç‹¬å çš„. æˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°æŠŠä½åˆ—é˜µå˜æˆæ•´æ•°æ•°ç»„ï¼Œæ¯æ’å…¥ä¸€ä¸ªå…ƒç´ ç›¸åº”çš„è®¡æ•°å™¨åŠ 1, è¿™æ ·åˆ é™¤å…ƒç´ æ—¶å°†è®¡æ•°å™¨å‡æ‰å°±å¯ä»¥äº†ã€‚ç„¶è€Œè¦ä¿è¯å®‰å…¨çš„åˆ é™¤å…ƒç´ å¹¶éå¦‚æ­¤ç®€å•ã€‚é¦–å…ˆæˆ‘ä»¬å¿…é¡»ä¿è¯åˆ é™¤çš„å…ƒç´ çš„ç¡®åœ¨å¸ƒéš†è¿‡æ»¤å™¨é‡Œé¢. è¿™ä¸€ç‚¹å•å‡­è¿™ä¸ªè¿‡æ»¤å™¨æ˜¯æ— æ³•ä¿è¯çš„ã€‚å¦å¤–è®¡æ•°å™¨å›ç»•ä¹Ÿä¼šé€ æˆé—®é¢˜ã€‚
****** Hash Collision:
******* å‰æï¼š Hash å‡½æ•°æ˜¯è‰¯å¥½çš„
******* å†²çªæ¦‚ç‡è®¡ç®—ï¼š å¦‚æœæˆ‘ä»¬çš„ä½é˜µåˆ—é•¿åº¦ä¸º m ä¸ªç‚¹ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬æƒ³å°†å†²çªç‡é™ä½åˆ°ä¾‹å¦‚ 1%, è¿™ä¸ªæ•£åˆ—è¡¨å°±åªèƒ½å®¹çº³ m/100 ä¸ªå…ƒç´ ï¼Œæ˜¾ç„¶è¿™å°±ä¸å«ç©ºé—´æœ‰æ•ˆäº† (Space-efficient).
******* è§£å†³æ–¹æ³•ä¹Ÿç®€å•ï¼Œå°±æ˜¯ä½¿ç”¨å¤šä¸ªHash, soï¼Œ å¦‚æœå®ƒä»¬æœ‰ä¸€ä¸ªè¯´å…ƒç´ ä¸åœ¨é›†åˆä¸­ï¼Œé‚£è‚¯å®šå°±ä¸åœ¨ã€‚å¦‚æœå®ƒä»¬éƒ½è¯´åœ¨ï¼Œè™½ç„¶å­˜åœ¨å®ƒä»¬åœ¨è¯´è°çš„å¯èƒ½ï¼Œä½†æ˜¯ç›´è§‰åˆ¤æ–­è¿™ğŸ€„ï¸äº‹æƒ…çš„æ¦‚ç‡æ¯”è¾ƒä½ã€‚
****** å‚æ•°é€‰æ‹©ï¼š
******* 1, when n/m = 10 ï¼ˆthe number of bits per set element) and k = 7 (hash functions) the false positive probabilityis just over 0.008. ï¼ˆhttp://theory.stanford.edu/~rinap/papers/esa2006b.pdfï¼‰
******* 2,  So, if we expect the Bloom filter to contain N elements, reserve at least 10N bits. These bits all start in the â€œoffâ€ position.
****** æŠ€æœ¯å¯¹æ¯”ï¼š
******* hashtableï¼š hashè¡¨æ˜¯å¸¸ç”¨çš„é€‰å‹ï¼Œ ä½†æ˜¯ç¼ºç‚¹æ˜¯ä¼šæš‚ç”¨å¤§é‡çš„å­˜å‚¨ç©ºé—´ï¼ˆæ¯”å¦‚è¯´ï¼Œä¸€ä¸ªè±¡ Yahoo,Hotmail å’Œ Gmai é‚£æ ·çš„å…¬ä¼—ç”µå­é‚®ä»¶ï¼ˆemailï¼‰æä¾›å•†ï¼Œæ€»æ˜¯éœ€è¦è¿‡æ»¤æ¥è‡ªå‘é€åƒåœ¾é‚®ä»¶çš„äººï¼ˆspamerï¼‰çš„åƒåœ¾é‚®ä»¶ã€‚ä¸€ä¸ªåŠæ³•å°±æ˜¯è®°å½•ä¸‹é‚£äº›å‘åƒåœ¾é‚®ä»¶çš„ email åœ°å€ã€‚ç”±äºé‚£äº›å‘é€è€…ä¸åœåœ°åœ¨æ³¨å†Œæ–°çš„åœ°å€ï¼Œå…¨ä¸–ç•Œå°‘è¯´ä¹Ÿæœ‰å‡ åäº¿ä¸ªå‘åƒåœ¾é‚®ä»¶çš„åœ°å€ï¼Œå°†ä»–ä»¬éƒ½å­˜èµ·æ¥åˆ™éœ€è¦å¤§é‡çš„ç½‘ç»œæœåŠ¡å™¨ã€‚å¦‚æœç”¨å“ˆå¸Œè¡¨ï¼Œæ¯å­˜å‚¨ä¸€äº¿ ä¸ª email åœ°å€ï¼Œ å°±éœ€è¦ 1.6GB çš„å†…å­˜ï¼ˆç”¨å“ˆå¸Œè¡¨å®ç°çš„å…·ä½“åŠæ³•æ˜¯å°†æ¯ä¸€ä¸ª email åœ°å€å¯¹åº”æˆä¸€ä¸ªå…«å­—èŠ‚çš„ä¿¡æ¯æŒ‡çº¹ï¼ˆè¯¦è§ï¼šgooglechinablog.com/2006/08/blog-post.htmlï¼‰ï¼Œ ç„¶åå°†è¿™äº›ä¿¡æ¯æŒ‡çº¹å­˜å…¥å“ˆå¸Œè¡¨ï¼Œç”±äºå“ˆå¸Œè¡¨çš„å­˜å‚¨æ•ˆç‡ä¸€èˆ¬åªæœ‰ 50%ï¼Œå› æ­¤ä¸€ä¸ª email åœ°å€éœ€è¦å ç”¨åå…­ä¸ªå­—èŠ‚ã€‚ä¸€äº¿ä¸ªåœ°å€å¤§çº¦è¦ 1.6GBï¼Œ å³åå…­äº¿å­—èŠ‚çš„å†…å­˜ï¼‰ã€‚å› æ­¤å­˜è´®å‡ åäº¿ä¸ªé‚®ä»¶åœ°å€å¯èƒ½éœ€è¦ä¸Šç™¾ GB çš„å†…å­˜ã€‚é™¤éæ˜¯è¶…çº§è®¡ç®—æœºï¼Œä¸€èˆ¬æœåŠ¡å™¨æ˜¯æ— æ³•å­˜å‚¨çš„ï¼‰
****** ç”¨ä¾‹åœºæ™¯ï¼š
******* Google è‘—åçš„åˆ†å¸ƒå¼æ•°æ®åº“ Bigtable ä½¿ç”¨äº†å¸ƒéš†è¿‡æ»¤å™¨æ¥æŸ¥æ‰¾ä¸å­˜åœ¨çš„è¡Œæˆ–åˆ—ï¼Œä»¥å‡å°‘ç£ç›˜æŸ¥æ‰¾çš„IOæ¬¡æ•°ï¼»3ï¼½ã€‚
******* Squid ç½‘é¡µä»£ç†ç¼“å­˜æœåŠ¡å™¨åœ¨ cache digests ä¸­ä½¿ç”¨äº†ä¹Ÿå¸ƒéš†è¿‡æ»¤å™¨ï¼»4ï¼½ã€‚
******* Venti æ–‡æ¡£å­˜å‚¨ç³»ç»Ÿä¹Ÿé‡‡ç”¨å¸ƒéš†è¿‡æ»¤å™¨æ¥æ£€æµ‹å…ˆå‰å­˜å‚¨çš„æ•°æ®ï¼»5ï¼½ã€‚
******* SPIN æ¨¡å‹æ£€æµ‹å™¨ä¹Ÿä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨åœ¨å¤§è§„æ¨¡éªŒè¯é—®é¢˜æ—¶è·Ÿè¸ªå¯è¾¾çŠ¶æ€ç©ºé—´ï¼»6ï¼½ã€‚
******* Google Chromeæµè§ˆå™¨ä½¿ç”¨äº†å¸ƒéš†è¿‡æ»¤å™¨åŠ é€Ÿå®‰å…¨æµè§ˆæœåŠ¡ï¼»7ï¼½ã€‚
******* ä¸šåŠ¡åœºæ™¯ä¸­åˆ¤æ–­ç”¨æˆ·æ˜¯å¦é˜…è¯»å¤šæŸè§†é¢‘æˆ–è€…æ–‡ç« ï¼Œæ¯”å¦‚æŠ–éŸ³æˆ–è€…å¤´æ¡ï¼Œå½“ç„¶ä¼šå¯¼è‡´ä¸€å®šçš„è¯¯åˆ¤ï¼Œ ä½†ä¸ä¼šè®©ç”¨æˆ·çœ‹åˆ°é‡å¤çš„å†…å®¹ã€‚ 
******* åœ¨å¾ˆå¤šKey-Valueç³»ç»Ÿä¸­ä¹Ÿä½¿ç”¨äº†å¸ƒéš†è¿‡æ»¤å™¨æ¥åŠ å¿«æŸ¥è¯¢è¿‡ç¨‹ï¼Œå¦‚ Hbaseï¼ŒAccumuloï¼ŒLeveldbï¼Œä¸€èˆ¬è€Œè¨€ï¼ŒValue ä¿å­˜åœ¨ç£ç›˜ä¸­ï¼Œè®¿é—®ç£ç›˜éœ€è¦èŠ±è´¹å¤§é‡æ—¶é—´ï¼Œç„¶è€Œä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨å¯ä»¥å¿«é€Ÿåˆ¤æ–­æŸä¸ªKeyå¯¹åº”çš„Valueæ˜¯å¦å­˜åœ¨ï¼Œå› æ­¤å¯ä»¥é¿å…å¾ˆå¤šä¸å¿…è¦çš„ç£ç›˜IOæ“ä½œï¼Œåªæ˜¯å¼•å…¥å¸ƒéš†è¿‡æ»¤å™¨ä¼šå¸¦æ¥ä¸€å®šçš„å†…å­˜æ¶ˆè€—ï¼Œä¸‹å›¾æ˜¯åœ¨Key-Valueç³»ç»Ÿä¸­å¸ƒéš†è¿‡æ»¤å™¨çš„å…¸å‹ä½¿ç”¨


#+begin_src c
       Do you have 'key1' ? -----------> Filter : NO
                    "Do not have" <-----------

       Do you have 'key2' ? -----------> Filter : YES    -----------> Storage : YES
                    "Do have"     <---------------------------------       Yes exists    <-----------
      
        Do you have 'key3' ? -----------> Filter : YES    -----------> Storage : No
                  "Do not have"     <----------------------------------  non-exists    <-----------      
#+end_src


***** bloom filterå¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜
******* If the number of changed paths is not too large (we use 512 as a limit in VSTS) then create a Bloom filter and seed it with the values for those paths
******* If there are more than 512 changes, then we mark the commit as â€œBloom filter too largeâ€ and check every path
******* one commit one bloom filter , â€œchanged paths on each commitâ€ as elements
***** Benifts
******* 100x by avoiding 99% of the computation theoretically.
******* In reality this is closer to a 6x speedup for a random sample of paths.
******* observed speedups as high as 20x for rarely-changed paths.
******* less than 100MB of extra storage for a repository the size of the Linux kernel.

*** https://devblogs.microsoft.com/devops/updates-to-the-git-commit-graph-feature/
***** rewriting the entire file is slow sometimes, so it also support multi-commit-graph
***** we can use `--split` to ceate a incremental commit-graph file
#+begin_src shell
  git commit-graph write --reachable
  git commit --allow-empty -m "empty"
  git commit-graph write --reachable --split

The

â€â€split option enables creating a chain of commit-graph files. If you ever run the command without the â€â€split option, then the chain will merge into a single file.
#+end_src
***** we can use `--size-multiple=<X>` and `--max-commits=<M>` to merge commit-graph files
*** https://github.blog/2020-07-27-highlights-from-git-2-28/#changed-path-bloom-filters
*** [RFC] https://public-inbox.org/git/fca023a3-f849-4be8-db42-7027bfe7b0dc@gmail.com/


* Scences
*** git status (need to compute merge bases on server)
*** git log --graph (reports in topological order, algorithm walks every reachable commit before displaying a single commit to the user. Like Azure support a graph view of commits topotical ordered, filters like author/date_interval )
*** git log master -- The/Path/To/My/File.txt (on the repo main page)
* Configurations

* What I Learn?

***** ã€Šthe commit which has 66 parents in Linux Kernelã€‹: https://www.destroyallsoftware.com/blog/2017/the-biggest-and-weirdest-commits-in-linux-kernel-git-history
***** https://github.com/Microsoft/perfview the performance analysis tool mentioned in article by stolee
***** https://en.wikipedia.org/wiki/Depth-first_search DFS argorithem
***** how git find merge bases between A and B:  (https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph-iii-generations/#using-generation-number-in-merge-base-questions)
******  1. First walk: find boundary commits that both A and B are reachable then stop ( mark parents of boundaries as "uninteresting to specify the range of the second walk")
****** 2. Second walk: from A and B, to find the first interesting commit that is reachable from both.
****** 3. ç”±äºæ—¶é’Ÿåå·®å¯ä»¥æä¾›ä¸æ­£ç¡®çš„æäº¤é¡ºåºï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦éå†ä¸¤æ¬¡æäº¤:ä¸€æ¬¡æ˜¯åˆ†å‘â€œä»Aå¯è¾¾â€æ ‡è®°ï¼Œç¬¬äºŒæ¬¡æ˜¯åˆ†å‘â€œä»Bå¯è¾¾â€æ ‡è®°ã€‚
***** ã€Šgit log history simplificationã€‹ https://docs.microsoft.com/en-us/azure/devops/repos/git/git-log-history-simplification?view=azure-devops&viewFallbackFrom=vsts
*****  ã€Šbloom filterã€‹
****** https://en.wikipedia.org/wiki/Bloom_filter
****** https://www.cnblogs.com/liyulong1982/p/6013002.html
